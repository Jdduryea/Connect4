{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# An AI that can play connect 4, made with genetic deep learning\n",
    "import random\n",
    "import numpy as np\n",
    "import math\n",
    "\n",
    "# \n",
    "NUM_ROWS = 6\n",
    "NUM_COLS = 7\n",
    "empty_token = 0\n",
    "player_1_token = 1\n",
    "player_2_token = -1\n",
    "\n",
    "connect_x = 4 # Number of pieces that must be connected\n",
    "\n",
    "# Sigmoid function\n",
    "def sig(x):\n",
    "\treturn 1.0/(1.0+math.e**(-x))\n",
    "\n",
    "class NN:\n",
    "\t# Creates a new neural network with random weights\n",
    "\tdef __init__(self):\n",
    "\t\tself.bottom_layer = None\n",
    "\t\tself.hidden_layer = None\n",
    "\t\tself.output_layer = None\n",
    "\t\tself.num_hidden_neurons = 10\n",
    "\t\tself.num_output_neurons = 7\n",
    "\n",
    "\tdef set_random_weight(self):\n",
    "\t\t# each row is a neuron, each column is a weight\n",
    "\t\t# there is a neuron in the base layer for each element in the board\n",
    "\t\tself.bottom_layer = np.matrix([random.uniform(-1.0,1.0) for x in range(NUM_COLS*NUM_ROWS)])\n",
    "\t\thidden_layer = []\n",
    "\t\tfor n in range(self.num_hidden_neurons):\n",
    "\t\t\tneuron = []\n",
    "\t\t\tfor w in range(self.bottom_layer.shape[1]):\n",
    "\t\t\t\trand = random.uniform(-1.0,1.0)\n",
    "\t\t\t\tneuron.append(rand)\n",
    "\t\t\thidden_layer.append(neuron)\n",
    "\t\tself.hidden_layer = np.matrix(hidden_layer)\n",
    "\n",
    "\t\t# One neuron for each column, sigmoid activation to find the highest probability\n",
    "\t\tnum_output_neurons = NUM_COLS\n",
    "\t\toutput_layer = []\n",
    "\t\tfor n in range(self.num_output_neurons):\n",
    "\t\t\tneuron = []\n",
    "\t\t\tfor w in range(self.hidden_layer.shape[0]):\n",
    "\t\t\t\trand = random.uniform(-1.0,1.0)\n",
    "\t\t\t\tneuron.append(rand)\n",
    "\t\t\toutput_layer.append(neuron)\n",
    "\t\tself.output_layer = np.matrix(output_layer)\n",
    "\n",
    "\t# Set weights of the neural net manually, really just used in spawning\n",
    "\tdef set_weights(self, bottom_layer, hidden_layer, output_layer):\n",
    "\t\tself.bottom_layer = bottom_layer\n",
    "\t\tself.hidden_layer = hidden_layer\n",
    "\t\tself.output_layer = output_layer\n",
    "\t\n",
    "\n",
    "\tdef feed_forward(self, input):\n",
    "\t\t# input should be a matrix\n",
    "\t\t# Flatten the input\n",
    "\t\tflat_input = [item for sublist in input for item in sublist]\n",
    "\t\t# X = np.dot(flat_input,self.bottom_layer)\n",
    "\t\tX = [a*b for a,b in zip(flat_input,self.bottom_layer.tolist()[0])]\n",
    "\t\tsiged = np.matrix(map(sig,X)).transpose()\n",
    "\t\t#siged = siged.transpose()\n",
    "\t\tX2 = np.dot(self.hidden_layer,siged)\n",
    "\t\tX2= X2.transpose().tolist()[0]\n",
    "\t\tsiged2 = np.matrix(map(sig,X2)).transpose()\n",
    "\t\tX3 = np.dot(self.output_layer, siged2)\n",
    "\t\tX3= X3.transpose().tolist()[0]\n",
    "\t\tresults = map(sig,X3)\n",
    "\t\treturn results\n",
    "\n",
    "\t# Returns a slightly modified version of this NN\n",
    "\tdef spawn(self,adjust_rate=0.01):\n",
    "\t\t# For each layer of weights, add a random weight matrix (small weights) of the same size to adjust the weights\n",
    "\t\tbottom_layer_adjustment = np.matrix([random.uniform(-adjust_rate,adjust_rate) for x in range(NUM_COLS*NUM_ROWS)])\n",
    "\t\t\n",
    "\t\thidden_layer_adjustment = []\n",
    "\t\tfor n in range(self.num_hidden_neurons):\n",
    "\t\t\tneuron = []\n",
    "\t\t\tfor w in range(len(bottom_layer_adjustment)):\n",
    "\t\t\t\trand = random.uniform(-adjust_rate,adjust_rate)\n",
    "\t\t\t\tneuron.append(rand)\n",
    "\t\t\thidden_layer_adjustment.append(neuron)\n",
    "\t\thidden_layer_adjustment = np.matrix(hidden_layer_adjustment)\n",
    "\n",
    "\t\toutput_layer_adjustment = []\n",
    "\t\tfor n in range(self.num_output_neurons):\n",
    "\t\t\tneuron = []\n",
    "\t\t\tfor w in range(len(self.hidden_layer)):\n",
    "\t\t\t\trand = random.uniform(-1.0,1.0)\n",
    "\t\t\t\tneuron.append(rand)\n",
    "\t\t\toutput_layer_adjustment.append(neuron)\n",
    "\t\toutput_layer_adjustment = np.matrix(output_layer_adjustment)\n",
    "\n",
    "\t\tbottom_layer = self.bottom_layer + bottom_layer_adjustment\n",
    "\t\thidden_layer = self.hidden_layer + hidden_layer_adjustment\n",
    "\t\toutput_layer = self.output_layer + output_layer_adjustment\n",
    "\n",
    "\t\tnew_nn = NN()\n",
    "\t\tnew_nn.set_weights(bottom_layer, hidden_layer, output_layer)\n",
    "\t\treturn new_nn\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#Create the board space\n",
    "def create_board(n_rows, n_cols):\n",
    "\tboard = []\n",
    "\trow = []\n",
    "\tfor i in range(n_cols):\n",
    "\t\trow.append(empty_token)\n",
    "\tfor i in range(n_rows):\n",
    "\t\tboard.append(list(row))\n",
    "\treturn board\n",
    "\n",
    "def print_board(board):\n",
    "\tfor row in range(NUM_ROWS):\n",
    "\t\tline = \"\"\n",
    "\t\tfor col in range(NUM_COLS):\n",
    "\t\t\tline += \"| \" + str(board[row][col]) + \" \"\n",
    "\t\tprint line\n",
    "\t\tprint \"----------------------------\"\n",
    "\n",
    "# Finds the last index of a item in a list\n",
    "def rindex(mylist, myvalue):\n",
    "    return len(mylist) - mylist[::-1].index(myvalue) - 1\n",
    "\n",
    "# Plays a move on the board, mutates the board object\n",
    "# TODO: make sure we can still play there\n",
    "def play_move(column,player, board):\n",
    "\t# Column: which column to play on\n",
    "\t# Player: which player is playing, 1 or 2\n",
    "\ttoken = \"\"\n",
    "\tif player == 1:\n",
    "\t\ttoken = player_1_token\n",
    "\telse:\n",
    "\t\ttoken = player_2_token\n",
    "\n",
    "\t# Find the row the piece would fall in, find last 0\n",
    "\tcolumn_values = [c[column] for c in board]\n",
    "\trow = rindex(column_values,empty_token)\n",
    "\tboard[row][column] = token\n",
    "\n",
    "# Checks the board to see if someone one. Returns that player if so, or else returns None\n",
    "\n",
    "def is_subsequence(x,y):\n",
    "\ttemp_x = \"\"\n",
    "\ttemp_y = \"\"\n",
    "\tfor c in x:\n",
    "\t\ttemp_x += str(c)\n",
    "\tfor c in y:\n",
    "\t\ttemp_y += str(c)\n",
    "\treturn temp_x in temp_y\n",
    "\n",
    "# returns true if there is still room in the given column for a piece\n",
    "def check_full_column(board, column):\n",
    "\tcolumn_values = [c[column] for c in board]\n",
    "\tif len([c for c in column_values if c != 0])== NUM_ROWS:\n",
    "\t\treturn True\n",
    "\n",
    "def did_win(board):\n",
    "\t# Check to see if these sequences are subsequences of rows, columns, or diags in the board\n",
    "\twin_1 = [player_1_token]*connect_x\n",
    "\twin_2 = [player_2_token]*connect_x\n",
    "\n",
    "\t# Check horizontal wins\n",
    "\tfor row in board:\n",
    "\t\tif is_subsequence(win_1, row):\n",
    "\t\t\treturn \"Player 1 Wins\"\n",
    "\t\telif is_subsequence(win_2, row):\n",
    "\t\t\treturn \"Player 2 Wins\"\n",
    "\t# Check column wins\n",
    "\tfor col in range(NUM_COLS):\n",
    "\t\tcolumn = [x[col] for x in board]\n",
    "\t\tif is_subsequence(win_1, column):\n",
    "\t\t\treturn \"Player 1 Wins\"\n",
    "\t\telif is_subsequence(win_2, column):\n",
    "\t\t\treturn \"Player 2 Wins\"\n",
    "\n",
    "\t# Check for diagonal wins\n",
    "\ta = np.array(board)\n",
    "\tdiags = [a[::-1,:].diagonal(i) for i in range(-a.shape[0]+1,a.shape[1])]\n",
    "\tdiags.extend(a.diagonal(i) for i in range(a.shape[1]-1,-a.shape[0],-1))\n",
    "\tfor diag in diags:\n",
    "\t\tif is_subsequence(win_1, diag):\n",
    "\t\t\treturn \"Player 1 Wins\"\n",
    "\t\telif is_subsequence(win_2, diag):\n",
    "\t\t\treturn \"Player 2 Wins\" \n",
    "\n",
    "\treturn \"No Winner Yet\"\n",
    "\n",
    "# Returns true if the board is full, false otherwise\n",
    "def board_is_full(board):\n",
    "\tfor row in board:\n",
    "\t\tfor col in row:\n",
    "\t\t\tif col == 0:\n",
    "\t\t\t\treturn False\n",
    "\treturn True\n",
    "\n",
    "# Returns the next player given the current player\n",
    "def switch_player(player):\n",
    "\tif player == 1:\n",
    "\t\treturn 2\n",
    "\telse:\n",
    "\t\treturn 1\n",
    "\n",
    "def get_inverted_board(board):\n",
    "\tinv_board = []\n",
    "\tfor row in board:\n",
    "\t\tnew_row = [-1*x for x in row]\n",
    "\t\tinv_board.append(new_row)\n",
    "\treturn inv_board\n",
    "\n",
    "# Inputs two neural networks, they do battle at Connect 4, the winning network is returned\n",
    "def battle(nn1,nn2, iteration):\n",
    "\t# Create new board\n",
    "\tnns = [nn1, nn2]\n",
    "\tboard = create_board(NUM_ROWS,NUM_COLS)\n",
    "\tplayer = 1\t# Player 1 goes first\t\n",
    "\twhile True:\n",
    "\t\tnn = nns[player-1] # gets the network player\n",
    "\n",
    "\t\t# Player 2 gets an inverted board, ie 1s become -1s vice versa\n",
    "\t\tprobs = []\n",
    "\t\tif player == 1:\n",
    "\t\t\tprobs = nn.feed_forward(board)\n",
    "\t\tif player == 2:\n",
    "\t\t\tprobs = nn.feed_forward(get_inverted_board(board))\n",
    "\t\t\n",
    "\t\tmove_choices = list(probs) # Makes sure the indices are kept track of\n",
    "\t\tprobs.sort(reverse=True) # Sort so we can pick the best option\n",
    "\t\tfor prob in probs:\n",
    "\t\t\tmove = move_choices.index(prob)\n",
    "\t\t\tif not check_full_column(board,move):\n",
    "\t\t\t\tplay_move(move,player, board)\n",
    "\t\t\t\tbreak\n",
    "\n",
    "\t\tif iteration == 99:\n",
    "\t\t\tprint_board(board)\n",
    "\t\t\tprint \" \"\n",
    "\n",
    "\t\t# Check win\n",
    "\t\tif did_win(board) != \"No Winner Yet\":\n",
    "\t\t\t#print \"Player \" + str(player) + \" Wins!!\"\n",
    "\t\t\t#print_board(board)\n",
    "\t\t\treturn nn\n",
    "\n",
    "\t\t# Check tie. If there is a tie, just return NN1 as the winner\n",
    "\t\tif board_is_full(board):\n",
    "\t\t\t#print \"Tie Game\"\n",
    "\t\t\treturn nn1\n",
    "\n",
    "\t\n",
    "\n",
    "\n",
    "\t\tplayer = switch_player(player)\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      " \n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      " \n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      " \n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      " \n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      " \n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      " \n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 0 | 0 | 0 \n",
      "----------------------------\n",
      "| 0 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      "| -1 | 0 | 0 | 0 | 1 | 0 | 0 \n",
      "----------------------------\n",
      " \n"
     ]
    }
   ],
   "source": [
    "NN_1 = NN()\n",
    "NN_1.set_random_weight()\n",
    "NN_2 = NN()\n",
    "NN_2.set_random_weight()\n",
    "\n",
    "for i in range(100):\n",
    "    winner = battle(NN_1,NN_2, i)\n",
    "    NN_1 = winner\n",
    "    NN_2 = NN_1.spawn()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
